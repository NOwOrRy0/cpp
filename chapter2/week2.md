# Chapter 2

## Type

- C++에는 $Type$ 이 존재합니다. 숫자, 문자에 따라 알맞는 Type을 사용해야 합니다.

### Type의 사용사례

> Type마다 메모리에 저장되는 크기가 다르기 때문에 적절한 Type을 선언해야합니다.

```c++
// 온도값을 소수점 두 번째 자리까지 사용하기위해서 float , double Type을 사용합니다.
float temprature = 25.53;

// 숫자와 문자를 포함한 12자리 계정을 담기위해 char array를 사용합니다.
char id[12];

// 수학 문제의 답이 0~1000까지만 나올 때 unsigend short를 사용합니다.
unsigned short mathanswer;
```

---

### Type 목록

#### 정수 Type

1. 부호 없는 정수 Type
   > 0을 포함한 자연수를 부호 없는 정수 unsigned type이라고 한다.

- unsigned short : 0 ~ 65,535
- unsigned int , unsigned long : 0 ~ 4,294,967,295
- unsigned long long , unsigned \_\_int64 : 0 ~ 18,446,744,073,709,551,615
  > 차이점은 Type마다 비트수가 다르다는 것이다.

---

2. 부호 있는 정수 Type

   ###### 음의 정수 표현

   - MSB에 부호비트를 사용함으로써 0에 대해 0, -0 두 값이 생기기 때문에 따라서 4비트에 16개가 아닌 15개의 숫자밖에 표현하지 못하게되는 문제가 있다. 이런 대응 규칙을 사용할 경우 CPU의 가산 회로의 설계가 복잡해질 수 있다. 회로가 복잡할수록 CPU의 성능은 떨어진다. 이런 단점으로 인해서 부호비트 대신 **2의 보수**를 사용한다.

   ###### 1의 보수

   - 어떤 수를 비트열로 나탙냈을 때 각 비트를 반전시킨 것을 1의 보수라고 한다. 예를 들면 5라는 수를 4비트열로 표현할 경우 [0101]이 되는데 1의 보수는 [1010]이다.

   ###### 2의 보수

   - 1의 보수값에 1을 더한값이 2의 보수이다. 따라서 [0101]에 1의 보수를 하면 [1010]에 1을 더한 [1011]이 된다.

   > 부호 있는 정수는 signed표기를 따로하지 않습니다.

   - long의 경우 시스템에 따라 4바이트, 8바이트로 해석될 수 있어 호환성문제가 발생할 수 있다.

   - Windows에서의 Type

   1. short : 2Byte
   2. int : 4Byte
   3. \_\_int64 : 8Byte

   - Linux에서의 Type

   1. short : 2Byte
   2. int : 4Byte
   3. long long : 8Byte

3. 부동소수점 타입

##### IEEE754

- 실수를 비트열로 대응시키기위한 방법

###### 고정소수점과 부동소수점

1.  고정소수점 : 소수점 위치가 고정된 형태를 의미한다.
    > 3.141592
2.  부동소수점 : 소수점 위치가 고정되어 있지 않음을 의미한다.
    > 314592 x 10E-6 , 314.592 x 10E-2 , 0.0341592 x 10E2

지수를 사용하면 하나의 실수를 소수점의 위치를 변경하면서 다양하게 표현할 수 있다.
그에 비해 고정소수점은 지수를 사용하지 않기 때문에 늘 소수점의 위치는 정해져 있으며, 소수점 위치를 기준으로 정수부와 소수부가 나누어진다.

###### 10진수를 2진수로 변환

```
정수부와 소수부로 구별한후
정수부 변환 : -5.375의 5를 2진수로 변환 101
소수부 변환 : 0.375에 2를 곱한 후 정수부 값을 추출
0.375 * 2 = 0.75 > 0
0.75 * 2 = 1.5 > 1
0.5 * 2 = 1.0 > 1
-101.011이 된다.
```

###### 정규화

10진수의 정규화 : 정수부를 0으로 만들고 소수점 바로다음이 0이 아닌수가 되도록하는 것이다.
3.141592를 정규화 하면 0.3141592 \* 10E1가 된다.

2진수의 정규화 : 2진수의 정규화는 정수부가 1이 되도록한다.
-101.011을 정규화 할 경우 -1.01011 \* 2E2 가된다.

|  Type  | 부호(비트) | 지수(비트) | 유효 숫자(비트) | 총합(비트) |
| :----: | :--------: | :--------: | :-------------: | :--------- |
| float  |     1      |     8      |       23        | 32         |
| double |     1      |     11     |       52        | 64         |

부호비트 : 양수 0 , 음수 1
지수비트, 유효숫자의 비트수가 double이 더 높으므로 표현할 수 있는 수의 범위가 늘어나고 더 정밀하다.
부동소수점은 실수를 표현하기 위함도 있지만 아주 작은수와 아주 큰 수를 표현하기 위한 것이다.

## 연습문제

1. (1)는 조건에 따라서 도체 혹은 부도체가 된다. 컴퓨터는 전류가 흐르는 경우를 (2), 흐르지 않는 경우를 (3)으로 약속하여 처리한다.
   (1) : 반도체
   (2) : 1
   (3) : 0

2. 특정한 집합에 포함된 대상을 일정한 대응 규칙에 의해서 비트열로 표현하는 체계를 (1) 이라고 한다.
   (1) : Type

3. C/C++는 수와 문자를 쉽게 처리하기 위하여 기본 타입을 제공한다. 기본 타입을 다섯 개이상 나열하시오.

- (unsigned) char
- (unsigned) short
- (unsigned) int
- (unsigned) long
- (unsigned) longlong
- \_\_int64
- float
- double

4. C++는 정수 타입을 (1)의 존재 여부에 따라서 크게 두 가지로 나눈다.
   (1) : 부호

5. unsigned short는 2바이트를 사용한다. unsigned short가 표현할 수 있는 정수의 범위를 나타내어라.

- 0 ~ 65535

6. 어떤 수를 2진법의 비트열로 나타냈을 때, 각 비트를 반전시킨 것을 (1)라고 한다. 2의 보수는 1의 보수에 (2)을 더한 것이다.
   (1) : 1의 보수
   (2) : 1

7. -8을 2의 보수법에 의해서 1바이트 비트열로 나타내어라.

```
-8 -> 1바이트 비트열로 나타내기
1. 8 = 0000 1000
2. 1의 보수 -> 1111 0111
3. 1을 더한다. -> 1111 1000
4. 1111 1000 = -8
```

8. 실수를 비트열로 나타내기 위하여 전기전자기술협회(IEEE)가 정한 표준은 무엇인가?

- IEEE754

9. -5.375를 2진법으로 나타내어라.

```
1. 5를 먼저 2진법으로 나타낸다.
101
2. 0.375를 2진법으로 나타낸다.
- 0.375 * 2 = 0.75 -> 0
- 0.75 * 2 = 1.5 -> 1
- 0.5 * 2 = 1.0 -> 1
011

3. 결과
- 101.011

```

10. 9번의 답을 정규화하여 부호, 지수, 유효 숫자를 말해보시오.

```
2진수에서 정규화는 정수부를 1로 만들고 나머지를 전부 소수부와 2의 거듭제곱의 곱셈 형태로 만드는 것이다.
101.011 에서 정규화를 하면 -1.01011 * 2E2가 된다.
부호비트 : 1
지수비트 : 1000 0001
유효숫자 : 0101 1000 0000 0000 000
```

11. int와 float는 크기가 4바이트로 같지만 float의 표현 범위가 훨씬 넓다. 대신 int에 비하여 어떤 점이 단점이 될 수 있는지 말해보시오.

- 지수가 23초과시 정수부의 오차범위가 증가되어 정확한 정수표현에 어려움이 있다.

12. 정수 타입을 부동소수점 타입으로 변환할 경우 주의점은 무엇인가.

- float은 2E23, double은 2E53을 초과하는 경우 정밀도를 잃을 수 있다. 따라서 해당 값보다 작을경우에만 변환 시 정수값이 보존된다.

13. UTF-8과 UTF-16을 서로 비교하여 각각의 장단점을 말해보시오.

```
1.1 UTF-8의 장점
- 1~4바이트로 대부분의 언어를 표현할 수 있다.
- 1바이트 : U+0000 ~ U+007F (7비트, ASCII 문자)
- 2바이트 : U+0080 ~ U+07FF (11비트, 확장된 라틴 문자 및 기타 언어어)
- 3바이트 : U+0800 ~ U+FFFF (16비트, 대부분의 비-ASCII 문자)
- 4바이트 : U+10000 ~ U+10FFFF (21비트, 이모지 및 고대문자)
- ASCII와 완벽호환되며 웹과 같은 글로벌환경에서 표준으로 사용됩니다.

1.2 UTF-8의 단점
- 한글 한자와 같은 문자를 3바이트로 표현하여 UTF-16보다 1바이트 더 사용하여 메모리 효율이 떨어질 수 있다.
- UTF-8은 문자 당 가변 길이를 사용하므로, 특정 문자에 대한 인덱싱이나 문자 탐색이 복잡할 수 있습니다.

2.1 UTF-16의 장점
- 한글, 한자와 같은 모든 언어를 2바이트로 취급하여 언어독립적인 플랫폼에서 유용하게 사용된다.
- 고정길이로 인코딩된 문자에 대해서는 인덱싱과 문자 탐색이 UTF-8보다 효율적일 수 있습니다.
- 다국어 환경에서도 상대적으로 일관성 있는 처리 방식을 제공합니다.
2.2 UTF-16의 단점
- 영어와 같은 ASCII 문자도 2바이트로 인코딩되므로, 이 경우 메모리 낭비가 발생할 수 있습니다.
- 다중 바이트 인코딩이 필요할 때(예: 보충 평면의 문자) 4바이트로 처리해야하므로, 고정 길이 인코딩의 장점이 깨질 수 있습니다.
- 기존 ASCII 기반 시스템과의 호환성이 떨어지며, UTF-8보다 널리 사용되지 않는 환경이 있을 수 있습니다.
- 서로 다른 플랫폼에서 UTF-16의 엔디안 문제가 발생할 수 있어, 데이터를 교환할 때 주의가 필요합니다.


```

15. Escape Sequence 중 연결이 잘못된 것을 고르시오.

- \b - Bell (x) -> Backspace (o)

16. NULL 종료 문자열을 설명하시오.

- C/C++ 환경에서 문자열을 다루는 표준함수에서는 문자의 끝을 '\0'를 이용하여 문자열의 종료를 인식합니다.
- 문자열에 NULL 종료 문자가 없으면 의도하지 않는 메모리 영역까지 접근하여 오류나 예기치 못한 동작을 일으킬 수 있습니다.

17. 다음 코드에서 잘못된 부분을 찾아내고 이유를 설명하시오.

```cpp
void main()
{
  char str1[8] = "C++";
  char str2[] = "C++";
  char str3[8];
  str3 = "C++";
}
/*
  잘못된 부분 str3
  문자 배열은 선언 후에 대입 연산자로 값을 할당할 수 없습니다. 배열 이름은 상수 포인터처럼 동작하므로, 배열에 대입을 하려는 시도가 잘못된 것 입니다.
  배열을 초기화할 때는 문자열 맅터럴로 초기화하는 것은 가능아니면 그 이후로는 strcpy, memset과 같은 함수를 사용해야 합니다.
*/
```

18. int요소가 네 개인 배열이 3개 모인 타입을 파생하시오.

```
1. int [NP] 타입을 기준으로 우측에 이름영역을 정의
2. int [NP][4] int요소가 4개인 배열을 선언 ,이름 영역 우측에 붙힌다.
3. int [NP][3][4] int요소가 4개인 배열 3개를 선언 , 이름 영역 우측에 붙힌다.
```

19. int 요소 네 개가 모인 배열을 가리키는 포인터 타입을 파생하시오.

```
1. int [NP] 타입을 기준으로 우측에 이름영역을 정의
2. int *[NP] 이름 영역 좌측에 참조 연산자를 붙힌다.
3. int (*[NP])[4] 연산자 우선순위를 고려하여 포인터와 이름영역을 괄호로 묶고 우측에 첨자연산자를 붙힌다.
```

20. int 요소 4개가 모인 배열을 가리키는 포인터를 반환하는 함수를 파생하시오(함수의 매개변수는 없다.).

```
1. int [NP] 타입을 기준으로 우측에 이름영역을 정의
2. int [NP]() 이름영역을 기준으로 우측에 매개변수 괄호 정의
3. int *[NP]() 이름영역 좌측에 참조 연산자 정의
4. int (*[NP]())[4] 연산자 우선순위를 고려하여 괄호 바깥에 첨자연산자 정의
5. int (*func())[4]
```

21. int 요소 3개인 배열이 2개 모인 배열 타입을 typedef를 이용하여 사용자 정의 타입으로 INT_ARR_23으로 만드시오.

```
1. int INT_ARR_23 타입을 기준으로 우측에 이름영역을 정의
2. int INT_ARR_23[3] 이름영역 우측에 첨자연산자 정의
3. int INT_ARR_23[2][3] 이름영역 우측에 첨자연산자 추가 정의
4. typedef int INT_ARR_23[2][3] 타입 좌측에 typedef 정의
```

22. 다음 함수에서 잘못된 부분을 찾은 후 고치시오.

```cpp
void main()
{
  /*
  원래코드
  const int ci;
  ci = 1;
   */
  const int ci = 1;

}
```

23. const int* 와 int * const 의 차이를 설명하시오. 추가적으로 cont int \* const도 설명하시오.

```
const int*와 int* const 의 차이
const int* 는 포인터가 가르키는 대상에 const를 한정하는 것이고,
int* const는 포인터 자체에 const를 한정하는 경우이다.

포인터가 가르키는 대상에 대한 수정이 불가한 것이 const int*이고
포인터가 선언되는 동시에 대입이 이루어져야하고 가르키는 대상의 수정이 불가하지만 대상의 값은 수정할 수 있다.

const int * const 는 선언과 동시에 값의 수정이 불가능한 타입이다.(자주 사용하진 않음)
```

24. 다음 구문에서 auto는 어떤 타입으로 추론되는가?

```cpp
# include <iostream>
void main()
{
  auto a = 1;
  std::cout << a << std::endl;
}
// int로 추론된다.
```

### 프로그래밍 문제

1. 알파벳 'C' 부터 'K'까지 몇 개의 알파벳이 있는지 계싼하는 프로그램을 작성하시오.

```cpp
#include <iostream>
using namespace std;

int main()
{
    cout << 'K' - 'C' + 1 << endl;
    return 0;
}
```

2. Name 문자 배열을 정의한 후에 자신의 영문 이름을 배열 요소에 하나씩 입력한 후에 출력하는 프로그램을 작성하시오.

```cpp
#include <iostream>
using namespace std;

int main()
{
    char Name[4];
    cin >> Name[0];
    cin >> Name[1];
    cin >> Name[2];
    Name[3] = '\0';

    cout << Name << endl;
    return 0;
}
```

3. 다음은 분자, 분모를 입력받은 후 나눗셈 결과를 출력하는 프로그램이다. Divide 함수를 완성하시오.

```cpp
#include <iostream>
using namespace std;
double Divide(int a, int b)
{
  return (double)a/b;
}
int main()
{
  int a, b;
  cout << "분자를 입력하세요." << endl;
  cin >> a;
  cout << "분모를 입력하세요." << endl;
  cin >> b;

  auto r = Divide(a, b);
  cout << r << endl;
  return 0;
}
```

4. 다음은 알파벳 하나를 입력받은 후, 대소문자 여부를 출력하는 프로그램이다. CheckResult함수를 완성하시오.

```cpp
#include <iostream>
using namespace std;
void CheckResult(char alphabet)
{
  if (alphabet - 'a' <= 26 && alphabet -'a' >= 0)
    cout << "소문자 입니다." << endl;
  else if(alphabet - 'A' <= 26 && alphabet -'A' >= 0)
    cout << "대문자 입니다." << endl;
  else
    cout << "알파벳이 아닙니다." << endl;
}
int main()
{
  char alphabet;
  cout << "알파벳 하나를 입력하세요." << endl;
  cin >> alphabet;
  CheckResult(alphabet);
  return 0;
}

```
